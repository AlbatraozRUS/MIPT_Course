# FIFO:

## Критические секции:
- Борьба между writer за чтение уникального имени из transfer-fifo (22-32)
- Борьба за доступ к FIFO между writer и reader. (Reader: 41 - 69 , Writer: 47-63)

## Флешка:
- unlink удаляет имя из файловой системы. 
- Если это имя было последней ссылкой на файл и больше нет процессов, которые держат этот файл открытым, данный файл 						     удаляется и место, которое он занимает освобождается для дальнейшего использования, но если какие-либо процессы всё ещё держат этот файл открытым, то файл будет оставлен пока последний файловый дескриптор, указывающий на него, не будет закрыт.

Если все файловые дескрипторы, указывающие на этот файл, закрыты, это имя было последней ссылкой на файл и unlink вернул успех
	
## Один и тот ли это файл: 
- Можно с помощью функции fstat(). Вытягиваем из структуры stat поля st_dev и st_ino. Если совпадают, то да.

- Мы можем переименовать файлы (между open). Или же мы можем сделать remove. А также еще вариант с mount для какого-нибудь устройства с таким же путем до файла и результат программы будет некорректной


## Mkfifo with mode:
- Ничего не выведет, так как mode не 0666, а 666. То есть банально не та константа. Еще вариант, что в umask может быть мусор, поэтому надо сделать umask(0);
- Если у нас sudo или такая фифочка уже была. 

## Для fifo в каких случаях open возвращает успех при открытии с O_NONBLOCK?
Открытие только для чтения завершается успешно, даже если на стороне записи еще никто не открывался, а открытие только для записи завершается 			неудачно с ENXIO, если другой конец еще не был открыт. Потому что если одновременно не открывать, то никогда не получится открыть. А если одновременно открывать, то у тебя нет возможности узнать, что ты умрешь если будешь писать в pipe (SIGPIPE).

# Messages: 
## Критические секции:
- Борьба между детьми за выходной поток (stdout)
- У нас текст складируется в буфер printf() и в определенный момент, когда буфер будет заполнен (n количество детей, которые записали в буфер свой текст), текст n+1 ребенка пойдет сразу в stdout. (77 - 82)

# Semaphores:
## Критические секции:
writerы за доступ к разделяемой памяти


# Signals: 
## Критическая секции:
- За маску входных сигналов родителя (90-98. Аналог - Хэндлер родителя) 
- За маску входных сигналов ребенка (161-152. Аналог - Хэндлер ребенка)
- Выставлением c помощью prctl() в ребенке от fork(). (19-39)
- В родители от fork() до выставления обработчиков (там, где разрешаем получать их) (19 - 137) (с килом ребенка (может быть до sigsuspend))
- Обработчики родителя с самим родителем за переменную cur_bit (152)

## Когда процесс уходит:
Когда процесс ушел в состояние зомби и родитель сделал wait()

## Можно ли сделать, чтобы дети остались в таблице:
Да, если мы заменим дефолтный обработчик на игнорирование у родителя.
	
## Какие сигналы могут прийти при завершении:
- SIGCHLD, потом при prctl.
- SIGHUP рассылает лидер сессии при своей смерти. 
- Далее, если мы читали из трубы и умерли, то тому процессу, который писал, SIGPIPE.
- SIGIO в случае select или poll. 
- SIGCONT посылается, если в сессии были были процессы с SIGSTOP, а лидер сессии умер. 

## Если поменять местами форк и сигпроцмаск что будет?
Будет проблема из-за того, что возможна ситуация, когда ребенок отправит сигнал и начнет ждать сигнал от родителя, а потом родитель заблокирует сигналы и начнет 	ждать сигнала от ребенка и мы получим DEAD LOCK.
	
## Что происходит при segfault. Кто его детектирует и как?
Детектирует процессор, он посылает исключение pagefault операционной системе, а она уже его обрабатывает. А возникает он при обращении в недозволенную память.

# Proxy:
## Нет вопросов)